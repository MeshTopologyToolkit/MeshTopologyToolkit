using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;

namespace MeshTopologyToolkit.Ase
{
    /// <summary>
    /// Provides functionality to read and write Autodesk ASCII Scene (ASE) files.
    /// </summary>
    public class AseFileFormat : IFileFormat
    {
        /// <summary>
        /// Represents a collection of supported file extensions for the file format.
        /// </summary>
        /// <remarks>This static readonly field contains an array of <see cref="SupportedExtension"/>
        /// objects, each representing a specific file extension that is supported by the class.</remarks>
        static readonly SupportedExtension[] _extensions = new[] {
            new SupportedExtension("Autodesk ASCII Scene .ASE", ".ase"),
        };

        /// <summary>
        /// Represents a collection of supported file extensions for the file format.
        /// </summary>
        /// <remarks>This property contains an array of <see cref="SupportedExtension"/>
        /// objects, each representing a specific file extension that is supported by the class.</remarks>
        public IReadOnlyList<SupportedExtension> SupportedExtensions => _extensions;

        public bool TryRead(IFileSystemEntry entry, out FileContainer content)
        {
            content = new FileContainer();
            return false;
        }

        public bool TryWrite(IFileSystemEntry entry, FileContainer content)
        {
            using (var stream = entry.OpenWrite())
            {
                using (var sb = new StreamWriter(stream, new UTF8Encoding(false)))
                {
                    // Header
                    sb.WriteLine("*3DSMAX_ASCIIEXPORT 200");
                    sb.WriteLine("*COMMENT \"Generated by MeshTopologyToolkit.Ase\"");
                    sb.WriteLine();

                    // Scene block (minimal)
                    sb.WriteLine("*SCENE {");
                    sb.WriteLine($"\t*SCENE_FILENAME \"{Path.GetFileName(entry.Name)}\"");
                    sb.WriteLine("\t*SCENE_FIRSTFRAME 0");
                    sb.WriteLine("\t*SCENE_LASTFRAME 0");
                    sb.WriteLine("\t*SCENE_FRAMESPEED 30");
                    sb.WriteLine("\t*SCENE_TICKSPERFRAME 160");
                    sb.WriteLine("}");
                    sb.WriteLine();

                    foreach (var scene in content.Scenes)
                    {
                        foreach (var node in scene.VisitAllChildren())
                        {
                            var mesh = node.Mesh?.Mesh;
                            if (mesh != null)
                            {
                                // One geometry object
                                sb.WriteLine("*GEOMOBJECT {");
                                sb.WriteLine($"\t*NODE_NAME \"{node.Name}\"");
                                sb.WriteLine("\t*NODE_TM {");
                                sb.WriteLine($"\t\t*NODE_NAME \"{node.Name}\"");
                                sb.WriteLine("\t\t*INHERIT_POS 0 0 0");
                                sb.WriteLine("\t\t*TM_ROW0 1.0 0.0 0.0");
                                sb.WriteLine("\t\t*TM_ROW1 0.0 1.0 0.0");
                                sb.WriteLine("\t\t*TM_ROW2 0.0 0.0 1.0");
                                sb.WriteLine("\t\t*TM_ROW3 0.0 0.0 0.0");
                                sb.WriteLine("\t\t*TM_POS 0.0 0.0 0.0");
                                sb.WriteLine("\t}");
                                sb.WriteLine();

                                sb.WriteLine("\t*MESH {");

                                var positions = mesh.GetAttribute<Vector3>(MeshAttributeKey.Position);
                                var positionIndices = mesh.GetAttributeIndices(MeshAttributeKey.Position);
                                sb.WriteLine($"\t\t*MESH_NUMVERTEX {positions.Count}");

                                var numFaces = mesh.DrawCalls.SelectMany(_ => _.GetFaces()).Count();
                                sb.WriteLine($"\t\t*MESH_NUMFACES {numFaces}");
                                sb.WriteLine("\t\t*MESH_VERTEX_LIST {");
                                for (int i = 0; i < positions.Count; i++)
                                {
                                    var v = positions[i];
                                    sb.WriteLine($"\t\t\t*MESH_VERTEX {i} {v.X:0.####} {v.Y:0.####} {v.Z:0.####}");
                                }
                                sb.WriteLine("\t\t}");

                                sb.WriteLine("\t\t*MESH_FACE_LIST {");
                                int faceIndex = 0;
                                foreach (var drawCall in mesh.DrawCalls)
                                {
                                    foreach (var face in drawCall.GetFaces())
                                    {
                                        sb.WriteLine($"\t\t\t*MESH_FACE {faceIndex} A: {positionIndices[face.A]} B: {positionIndices[face.B]} C: {positionIndices[face.C]} AB: 1 BC: 1 CA: 1 *MESH_SMOOTHING 0 *MESH_MTLID 0");
                                        ++faceIndex;
                                    }
                                }
                                sb.WriteLine("\t\t}");
                                if (mesh.HasAttribute(MeshAttributeKey.TexCoord))
                                {
                                    var texCoord = mesh.GetAttribute<Vector3>(MeshAttributeKey.TexCoord);
                                    var texCoordIndices = mesh.GetAttributeIndices(MeshAttributeKey.TexCoord);
                                    sb.WriteLine($"\t\t*MESH_NUMTVERTEX {texCoord.Count}");
                                    sb.WriteLine("\t\t*MESH_TVERTLIST {");
                                    for (int i = 0; i < texCoord.Count; i++)
                                    {
                                        var v = texCoord[i];
                                        sb.WriteLine($"\t\t\t*MESH_TVERT {i} {v.X:0.####} {v.Y:0.####} {v.Z:0.####}");
                                    }
                                    sb.WriteLine("\t\t}");
                                    sb.WriteLine($"\t\t*MESH_NUMTVFACES {numFaces}");
                                    sb.WriteLine("\t\t*MESH_TFACELIST {");
                                    faceIndex = 0;
                                    foreach (var drawCall in mesh.DrawCalls)
                                    {
                                        foreach (var face in drawCall.GetFaces())
                                        {
                                            sb.WriteLine($"\t\t\t*MESH_TFACE {faceIndex} {texCoordIndices[face.A]} {texCoordIndices[face.B]} {texCoordIndices[face.C]}");
                                            ++faceIndex;
                                        }
                                    }
                                    sb.WriteLine("\t\t}");
                                }
                                if (mesh.HasAttribute(MeshAttributeKey.Normal))
                                {
                                    var normal = mesh.GetAttribute<Vector3>(MeshAttributeKey.Normal);
                                    var normalIndices = mesh.GetAttributeIndices(MeshAttributeKey.Normal);

                                    sb.WriteLine("\t\t*MESH_NUMCVERTEX 0");
                                    sb.WriteLine("\t\t*MESH_NORMALS {");
                                    faceIndex = 0;
                                    foreach (var drawCall in mesh.DrawCalls)
                                    {
                                        foreach (var face in drawCall.GetFaces())
                                        {
                                            var a = normal[normalIndices[face.A]];
                                            var b = normal[normalIndices[face.B]];
                                            var c = normal[normalIndices[face.C]];
                                            var faceNormal = Vector3.Normalize(a+b+c);
                                            sb.WriteLine($"\t\t\t*MESH_FACENORMAL {faceIndex} {faceNormal.X:0.####} {faceNormal.Y:0.####} {faceNormal.Z:0.####}");
                                            sb.WriteLine($"\t\t\t\t*MESH_VERTEXNORMAL {positionIndices[face.A]} {a.X:0.####} {a.Y:0.####} {a.Z:0.####}");
                                            sb.WriteLine($"\t\t\t\t*MESH_VERTEXNORMAL {positionIndices[face.B]} {b.X:0.####} {b.Y:0.####} {b.Z:0.####}");
                                            sb.WriteLine($"\t\t\t\t*MESH_VERTEXNORMAL {positionIndices[face.C]} {c.X:0.####} {c.Y:0.####} {c.Z:0.####}");
                                            ++faceIndex;
                                        }
                                    }
                                    sb.WriteLine("\t\t}");
                                }
                                sb.WriteLine("\t}");
                                sb.WriteLine();
                                sb.WriteLine("}");
                                sb.WriteLine();
                            }
                        }
                    }
                }
            }
            return true;
        }
    }
}
